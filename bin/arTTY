#!/usr/bin/env ruby

require "arTTY"
require "hilighter"
require "io/wait"
require "optparse"
require "scoobydoo"

class ArTTYExit
    GOOD = 0
    INVALID_OPTION = 1
    INVALID_ARGUMENT = 2
    MISSING_ARGUMENT = 3
    EXTRA_ARGUMENTS = 4
    EXCEPTION = 5
    AMBIGUOUS_ARGUMENT = 6
    UNSUPPORTED_ART = 7
end

def parse(args)
    options = Hash.new
    options["action"] = "draw"
    options["art"] = "none"
    options["clear"] = false
    options["fit"] = false
    options["fortune"] = false
    options["sysinfo"] = nil
    options["verbose"] = false

    info = "Art for your TTY."

    parser = OptionParser.new do |opts|
        opts.summary_width = 30

        opts.banner = "Usage: #{File.basename($0)} [OPTIONS] [art]"

        opts.on("", "DESCRIPTION")

        info.scan(/\S.{0,76}\S(?=\s|$)|\S+/).each do |line|
            opts.on("    #{line}")
        end

        opts.on("", "OPTIONS")

        opts.on("-c", "--clear", "Clear screen first") do
            options["clear"] = true
        end

        opts.on("-d", "--demo", "Demo all supported art") do
            options["action"] = "demo"
        end

        opts.on("--fit", "Use art that fits in the current window") do
            options["fit"] = true
        end

        opts.on("-f", "--fortune", "Display a fortune as well") do
            options["fortune"] = true
        end

        opts.on("-h", "--help", "Display this help message") do
            puts opts
            exit ArTTYExit::GOOD
        end

        opts.on(
            "-g",
            "--generate=IMAGE",
            "Generate ArTTY art from IMAGE (NAME_WxH.png)"
        ) do |image|
            options["action"] = "generate"
            options["art"] = image
        end

        opts.on("--ls", "--list-supported", "List supported art") do
            options["action"] = "list"
        end

        opts.on("-r", "--random", "Display random art") do
            options["action"] = "random"
        end

        opts.on(
            "--random-matching=PATTERN",
            "Display random art matching PATTERN"
        ) do |pattern|
            options["action"] = "random-matching"
            options["art"] = pattern
        end

        opts.on("-s", "--sysinfo", "Display system info as well") do
            options["sysinfo"] = ArTTY::SystemInfo.new
        end

        opts.on(
            "-v",
            "--verbose",
            "Show backtrace when error occurs"
        ) do
            options["verbose"] = true
        end

        opts.on("--version", "Show version") do
            __FILE__.match(/arTTY-(\d+\.\d+\.\d+)/) do |m|
                puts m[1]
            end
            exit ArTTYExit::GOOD
        end
    end

    begin
        parser.parse!
    rescue OptionParser::InvalidOption => e
        puts e.message
        puts parser
        exit ArTTYExit::INVALID_OPTION
    rescue OptionParser::InvalidArgument => e
        puts e.message
        puts parser
        exit ArTTYExit::INVALID_ARGUMENT
    rescue OptionParser::MissingArgument => e
        puts e.message
        puts parser
        exit ArTTYExit::MISSING_ARGUMENT
    rescue OptionParser::AmbiguousOption => e
        puts e.message
        puts parser
        exit ArTTYExit::AMBIGUOUS_ARGUMENT
    end

    if (args.length == 1)
        options["art"] = args[0]
    elsif (args.length > 1)
        puts parser
        exit ArTTYExit::EXTRA_ARGUMENTS
    end

    return options
end

options = parse(ARGV)

begin
    available = ArTTY.art

    # Don't worry about height for now
    if (options["fit"])
        # height = %x(tput lines).to_i
        width = %x(tput cols).to_i

        # sysinfo_height = 0
        sysinfo_width = 0
        if (options["sysinfo"])
            # sysinfo_height = options["sysinfo"].height
            sysinfo_width = options["sysinfo"].width
        end

        if (sysinfo_width >= width)
            available.clear
            options["sysinfo"] = nil
        else
            available.keep_if do |name, art|
                # total_height = 1 + [art.height, sysinfo_height].max
                total_width = 1 + art.width + 2 + sysinfo_width
                # (total_height <= height) && (total_width <= width)
                (total_width <= width)
            end
        end
    end

    case options["action"]
    when "random"
        options["art"] = available.keys.delete_if do |art|
            art == "none"
        end.shuffle[0] || "none"
    when "random-matching"
        options["art"] = available.keys.keep_if do |art|
            art.match?(/#{options["art"]}/)
        end.shuffle[0] || "none"
    end

    if (options["fit"] && !available.has_key?(options["art"]))
        options["art"] = "none"
    end

    case options["action"]
    when "demo"
        available.keys.sort.each do |name|
            next if (name == "none")
            art = ArTTY.get(name, options["sysinfo"]).draw
            puts "### #{name} ###".white
            puts "\n#{art}\n" if (!art.empty?)
        end
    when "generate"
        puts ArTTY::Generator.new.generate(options["art"])
    when "list"
        puts available.keys.sort
    else
        art = ArTTY.get(options["art"], options["sysinfo"]).draw
        system("clear") if (options["clear"])
        puts "\n#{art}\n" if (!art.empty?)
        if (options["fortune"] && ScoobyDoo.where_are_you("fortune"))
            system("fortune -s")
        end
    end
rescue ArTTY::Error => e
    $stderr.puts e.message.white.on_red
    if (options["verbose"])
        e.backtrace.each do |line|
            $stderr.puts line.yellow
        end
    end
    exit ArTTYExit::EXCEPTION
rescue Interrupt
    # ^C
    # Exit gracefully
rescue Errno::EPIPE
    # Do nothing. This can happen if piping to another program such as
    # less. Usually if less is closed before we're done with STDOUT.
rescue Exception => e
    $stderr.puts "Oops! Looks like an error has occured! If the " \
        "error persists, file a bug at:".wrap
    $stderr.puts
    $stderr.puts "    https://gitlab.com/mjwhitta/arTTY/issues"
    $stderr.puts
    $stderr.puts "Maybe the message below will help. If not, you " \
        "can use the --verbose flag to get a backtrace.".wrap

    $stderr.puts e.message.white.on_red
    if (options["verbose"])
        e.backtrace.each do |line|
            $stderr.puts line.light_yellow
        end
    end
    exit ArTTYExit::EXCEPTION
end
exit ArTTYExit::GOOD
